On-Device Multi-Agent Anomaly Detection System
Project for Samsung Ennovatex 2025

This document contains the complete technical overview, architecture, and user guide for the On-Device Multi-Agent Anomaly Detection System.

1. Approach and Uniqueness
Our Approach
The project addresses the need for a robust, privacy-preserving security mechanism on mobile devices. Traditional security methods often rely on static credentials (passwords, PINs) which are vulnerable to theft, or cloud-based analysis which raises privacy concerns.

Our system creates a dynamic, personalized security layer that understands a user's unique behavioral patterns to detect potential fraud, spoofing, or bot-like activity in real-time. It achieves this by building a mathematical model of the user's "normal" behavior using machine learning. An anomaly is defined as any significant deviation from this learned baseline.

What Makes It Unique
The uniqueness of this solution lies in three key principles:

Fully On-Device Processing: To guarantee user privacy, every stage—from raw data collection to model inference—is executed locally on the device. No sensitive behavioral data is ever transmitted to external servers. This also ensures low-latency detection that is independent of network connectivity.

Multi-Agent Architecture: Instead of a single, monolithic program, the system is architected as a collection of independent, specialized agents (e.g., Movement Agent, Typing Agent). These agents operate in parallel and report their findings to a central coordinator, creating a resilient and scalable system that can analyze multiple behavioral signals at once.

Context-Aware Security: The system is designed to only trigger security actions (like a re-authentication prompt) when an anomaly is detected during a sensitive operation (e.g., opening a banking app). This "just-in-time" security prevents unnecessary interruptions during casual use, solving common usability problems in continuous authentication systems.

2. Technical Stack
This project is built entirely on open-source software (OSS) libraries.

Platform: Android (Kotlin) - The native development platform for building the application.

Machine Learning (Training):

TensorFlow/Keras - For building and training the GRU autoencoder models in Python.

Scikit-learn - For data preprocessing, specifically using the MinMaxScaler.

Pandas - For data manipulation and loading CSV files.

Machine Learning (On-Device):

TensorFlow Lite - The core library for running ML models efficiently on mobile devices.

TFLite Flex Delegate - A crucial component that enables the use of advanced TensorFlow operations (like those in GRUs) within the TFLite runtime.

3. Technical Architecture
The system is designed as a modular, multi-agent system where each component has a distinct responsibility.

3.1. Agent Breakdown
Movement Agent (MovementAgent.kt): Analyzes the physical movement of the device using the accelerometer and a dedicated movement_model_gru.tflite.

Typing Agent (TypingAgent.kt): Analyzes the user's typing rhythm using a TextWatcher and a typing_model.tflite.

Coordinator Agent (Coordinator.kt): Acts as the central decision-making brain, receiving anomaly signals from all agents and applying risk assessment logic.

3.2. Data and Logic Flow
Data Sensing: The MainActivity captures raw data from device sensors.

Data Delegation: The raw data is passed to the Coordinator.

Agent Processing: The Coordinator forwards the data to the appropriate agent.

On-Device Inference: Each agent maintains a sequence of recent data. When a sequence is full, it is fed into the agent's .tflite model for inference.

Anomaly Reporting: Each agent calculates the model's reconstruction error and compares it to a pre-defined threshold to determine if an anomaly has occurred.

Risk Assessment & Action: The Coordinator collects the anomaly statuses and, if the context is sensitive, triggers a security response.

4. Implementation Details
4.1. Machine Learning Models
Both agents are powered by GRU (Gated Recurrent Unit) Autoencoder models. This architecture is highly effective at learning patterns in sequential data. The models are trained to reconstruct "normal" user behavior with low error. When presented with an anomalous pattern, the reconstruction error spikes, signaling an anomaly. The final models are converted to the .tflite format with quantization to ensure high performance and a small footprint on the device.

4.2. Android Application
The application is built natively in Kotlin. The core logic is separated into classes for each agent and the coordinator, with MainActivity.kt serving as the UI and event handler. The TFLite Interpreter is initialized with a FlexDelegate, which is critical for enabling the advanced operations required by the GRU models.

5. Installation Instructions
Clone the project repository from GitHub.

Open the project in the latest version of Android Studio.

Ensure you have the Android SDK for API level 33 or higher installed.

The project uses Gradle for dependency management. Allow Android Studio to sync and download all required libraries as defined in the app/build.gradle.kts file.

Connect a physical Android device with Developer Options and USB Debugging enabled.

Build and run the application on the device.

6. User Guide
The application is designed to run in the background with no direct user interaction required for its security functions.

Training Phase (Implicit): Upon first use, the app begins to silently learn the user's unique movement and typing patterns. For a robust baseline, the user should use their device normally for a few days.

Monitoring Phase: The app runs a persistent background service, continuously monitoring sensor and typing data.

Anomaly Detection: When an anomaly is detected (e.g., a different person is typing), the system logs it.

Security Action: If an anomaly is detected while the user is performing a sensitive action (e.g., opening a banking app), the system will present a biometric prompt (fingerprint/face) to re-verify the user's identity before allowing access.

7. Salient Features
Continuous, Passive Authentication: Verifies user identity continuously without requiring active input.

Privacy by Design: All user data remains on the device, ensuring maximum privacy.

High Efficiency: Optimized GRU models and native code ensure minimal impact on battery life and device performance.

Detects Multiple Threat Vectors: Effective against both robotic bots (which are too perfect) and human spoofers (who are imperfect in the wrong way).

Scalable Architecture: The multi-agent design allows for easy addition of new behavioral agents (e.g., App Usage, Location) in the future.
